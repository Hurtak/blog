- common mistakes in naming
  - parameter vs argument
  - function vs method
  - pararell vs serial
  - find other examples - also I should have something in my notes

- gitignore
  - .gitkeep

- async component loading
  - https://github.com/thejameskyle/react-loadable

- images done right
  - width & height properly set with img tags
  - responsive
    - width 100% height auto
  - sizes are properly set event on mobile
    - mixin for 16:9 size

- article optional array/object fields - sbread operator and before spread operator

- bash script basics
  - shebang
  - chmod u+x file
  - set -e
  - variables
  - cd to current directory
  - source file vs ./file
  - if else
  - functions
  - cli arguments
  - running stuff in background &
  - capturing pid and then killing background stuff

- CORS
  - CORS http requests
    - with credentials
  - headers
  - https://github.com/pillarjs/understanding-csrf/blob/master/README.md
  - simple cors proxy
    #!/usr/bin/env node

    const request = require('request')
    const express = require('express')
    const bodyParser = require('body-parser')
    const cors = require('cors')

    const port = process.env.REACT_APP_DEV_PROXY_PORT || 3001

    const app = express()
    app.use(bodyParser.json())
    app.use(
      cors({
        origin: (origin, callback) => callback(null, true),
        optionsSuccessStatus: 200 // some legacy browsers (IE11, various SmartTVs) choke on 204
      })
    )

    app.post('/', function (req, res) {
      const origin = req.get('origin')

      // TODO: might not be needed in the future as soon as dev api will stop
      // returning Access-Control-Allow-Origin header
      res.setHeader('Access-Control-Allow-Origin', origin)

      request({
        method: 'POST',
        url: req.body.apiUrl,
        json: true,
        body: {
          plugins: req.body.apiModules || [],
          url: req.body.queryUrl
        }
      })
        .on('response', response => {
          if (response.statusCode === 204) {
            response.statusCode = 200
          }

          // TODO: might not be needed in the future as soon as dev api will stop
          // returning Access-Control-Allow-Origin header
          response.headers['Access-Control-Allow-Origin'] = origin
        })
        .on('error', err => console.error('[PROXY]', err))
        .pipe(res)
    })

    app.listen(port)

- determine lightness of color
  - http://stackoverflow.com/questions/596216/formula-to-determine-brightness-of-rgb-color/24213274#24213274

- what every page should contain
  - <html lang="cs">
  - <meta charset="utf-8">
  - <meta name="viewport" content="width=device-width,initial-scale=1">
  - css border box reset
  - css body margin 0 stuff?
  - maybe mention
    - <title>Je čas.cz – moderní tvorba webových stránek</title>
    - <meta name="description" content="Poznámky o moderním webdesignu, hotová řešení, experimenty a návody.">

- web video
  - how to record on linux
    - vokoscreen
    - kdenlive
  - how to display in page
    - video element stuff

- hover image preloading
  - how browser decides what is fetched
  - js to preload images

- debian packaging introduction
  - basic packaging of static files
  - running some script during packaging (makefile override)
  - how dependencies work
  - how installation work

- JQ

- cross origin
  - why it was introduces
  - security limitations of responding *
  - proxy workaround

- cryptographically secure random number
  https://gist.github.com/joepie91/7105003c3b26e65efcea63f3db82dfba
  ## Cryptographic randomness

  The `window.crypto.getRandomValues()` function lets you get cryptographically strong random values. The array given as the parameter is filled with random numbers (random in its cryptographic meaning).

  This function takes TypedArray of certain size and fill it with random numbers in range of the typed array, eg if it is 8Bit array, values will be between 0-255.

  ```js
  const randomNumber = window.crypto.getRandomValues(new Uint8Array(1))[0]
  ```

  To guarantee enough performance, implementations are not using a truly random number generator, but they are using a pseudo-random number generator seeded with a value with enough entropy. The PRNG used differs from one implementation to the other but is suitable for cryptographic usages. Implementations are also required to use a seed with enough entropy, like a system-level entropy source.

  var cryptoStor = new Uint16Array(8);
  (In this case, we’re creating an array with eight different slots that can each contain an unsigned 16-bit integer. Other interger options include Int8Array, Uint8Array, int16Array, Int32Array and Uint32Array.

  Then, fill the array with random numbers of the defined type:

  window.crypto.getRandomValues(cryptoStor);
  Showing the collected values in the console:

  > [43484, 57947, 46691, 49849, 24272, 11827, 28203, 17423]
  The Web Cryptography API has good support in modern browsers, although it is vendor prefixed in some cases.

  - If you want numbers in certain range, you might do +min and %max, but that might leave uneven distribution. Add example code where we just ask for new number again.

  ```js
  function generateCryptoRandomNumber (min, max) {
    const distance = max - min
    const maxDistance = 2 ** 32 - 1

    if (distance > maxDistance) throw new Error('Maximum is too big')

    let randomNumber
    do  {
      randomNumber = window.crypto.getRandomValues(new Uint32Array(1))[0]
    } while (randomNumber >= maxDistance - (maxDistance % distance))

    return randomNumber % (distance + 1) + min
  }

  console.log(generateCryptoRandomNumber(1, 100))
  ```
